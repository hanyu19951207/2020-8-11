# 2020-8-11
461. 汉明距离
      两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。
      给出两个整数 x 和 y，计算它们之间的汉明距离。
      注意：
      0 ≤ x, y < 231.
      示例:
      输入: x = 1, y = 4
      输出: 2
      解释:
      1   (0 0 0 1)
      4   (0 1 0 0)
             ↑   ↑
      上面的箭头指出了对应二进制位不同的位置。
思路：
      要求两个数字对应二进制位不同的位置的数目，异或运算:相同为0，不同为1；
      那么汉明距离即为：将两个数字异或得到的数，计算其二进制表示的1的个数。
      计算二进制1的个数，把一个整数减去1之后再和原来的整数做位与运算，得到的结果相当于把整数的二进制表示中最右边的1变成0。
      举例分析：
      对11100进行减1操作，那么就变成11011，然后让11011和原数11100做与操作，结果变成了11000，相比之前的11100来说，做这样的一次运算之后，后边少了一个1，
      继续对11000进行减1操作，那么变成10111，让10111和11000做与操作，变成10000，然后继续对10000进行减1操作，变为01111，让10000和01111做与操作，结果为00000，
      则结束退出，总共循环3次，加上位运算加持，效率更高。
题解：
class Solution {
    public int hammingDistance(int x, int y) {
        int n = x ^ y;
        int count = 0;
        while(n != 0){
            n = n & (n - 1);
            count++;
        }
        return count;
    }
}

463. 岛屿的周长
     给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。
    网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。
    岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。
    示例 :
    输入:
    [[0,1,0,0],
     [1,1,1,0],
     [0,1,0,0],
     [1,1,0,0]]
    输出: 16
思路：
    这个题目的关键就是减掉相邻重复的边
    两块岛屿相邻就有两条重复的边
    所以就要判断它的 上 下 左 右 有没有岛屿(就是说有没有 1 )
题解：
class Solution {
    public int islandPerimeter(int[][] grid) {
		//定义总周长res为0
        int res=0;
		for(int i=0;i<grid.length;i++) {
			for(int j=0;j<grid[0].length;j++) {
				if(grid[i][j]==1) {
					//每个岛屿默认4条边
					int count=4;
					//看它的上方的那块是不是 1，是的话count减一
					if(i>0&&grid[i-1][j]==1)
						count--;
					//看它的下方的那块是不是 1，是的话count减一
					if(i<grid.length-1&&grid[i+1][j]==1)
						count--;
					//看它的左方的那块是不是 1，是的话count减一
					if(j>0&&grid[i][j-1]==1)
						count--;
					//看它的右方的那块是不是 1，是的话count减一
					if(j<grid[0].length-1&&grid[i][j+1]==1)
						count--;
					res+=count;
				}
			}
		}
		return res;  
    }
}

476. 数字的补数
    给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。
    示例 1:
    输入: 5
    输出: 2
    解释: 5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。
思路：
    题目要求即将num二进制各位由1变成0，0变成1，由此想到将各位与1做异或操作即可。如何找到与num二进制有效位（没有前导零位）个数相同且都是1的数呢？
    只要找到比num最高1位的位置高一位（左边）就行了，此时该数必然大于num，如num=5（101B）时，这个数为8（1000B），将其减1，则得到与num有效二进制位数相同且各位都为1的数。如8-1=7（111B）
题解：
public int findComplement(int num) {
        long num0 = 1;
        while(num0 <= num)
            num0 = num0 << 1;
        num0 -= 1;
        return (int)num0 ^ num;
    }
